
# 序言
## Fibonacci数列

多项式时间算法：
```js
var fib_arr = [0, 1];
function fib(n){
  if(n == 0){
    return 0;
  }else if(n == 1){
    return 1;
  }
  for (var i = 0; i < n-2; i++) {
    fib_arr[n+2] = fib_arr[n+1] + fib_arr[n]
  }
  return fib_arr[n]
}
var start = new Date().getTime();
console.log(fib(30));
var end = new Date().getTime();
console.log('运行时间：'+(end-start));
// 运行时间：24
```

指数时间算法：
```js
function fib(n){
  if(n == 0){
    return 0;
  }else if(n == 1){
    return 1;
  }else{
    return fib(n-1) + fib(n-2);
  }
}
var start = new Date().getTime();
console.log(fib(30));
var end = new Date().getTime();
console.log('运行时间：'+(end-start));
// 运行时间：50
```

## 渐进
- 上界：Ο
- 下界：Ω
- 紧确界：Θ

# 数字的算法

## 基础算数
### 基数和对数
- b为基数的k位数字最大为b^k-1
- b为基数表示N需要 ⌈log(b)(N+1)⌉ 位（应该是向上取整）

### 乘法（Al Khwarizmi乘法规则）
类似使用二进制进行乘法

y（每次整除2） | z（结果，由底至顶）
---|---
11 | `13+(13+(13*2)*2)*2`
5 | `13+(13*2)*2`
2 | `13*2`
1 | `13`
0 | `0`


```js
// 类似使用二进制进行乘法（当y>=0时可用）
function multiply(x, y){
  if(0 == y){
    return 0;
  }
  var z = multiply(x, Math.floor(y/2))
  // y为偶数，y为奇数加到x上
  return y%2 == 0 ? 2*z : x + 2*z;
}
console.log(multiply(13, 11));
```

### 除法
类似使用二进制进行除法

x（每次整除2） | z（结果，由底至顶）
---|---
13 | `[0+1, ((((0+1)*2+1)*2)*2+1)-11]`
6 | `[0, ((0+1)*2+1)*2]`
3 | `[0, (0+1)*2+1]`
1 | `[0, (0+1)]`
0 | `[0, 0]`

```js
// 类似使用二进制进行除法（当y>=1时可用，q：quotient，r：remainder）
function divide(x, y){
  if(0 == x){
    return [0, 0];
  }
  var z = divide(Math.floor(x/2), y);
  var q = 2 * z[0];
  var r = 2 * z[1];
  if (x%2 == 1) {
    // 被除数为奇数除二余数为1
    r++;
  }
  if (r >= y) {
    // 余数大于除数，余数变为余数减去除数，商+1
    r -= y;
    q++;
  }
  console.log(q, r);
  return [q, r];
}
console.log(divide(13, 11));
```

### 模运算

定义：`x=qN+r`，且`0<=r<N`，则x模N等于r。

- x与y模N同余 <=> x≡y(mod N) <=> N整除(x-y)
- 模运算准守结合律、分配率、交换律


### 模的指数运算

x:10, y:6, N:17

y（指数，每次整除2） | z（结果，由底至顶）
---|---
6 | `((10*((10*1*1)%17)*((10*1*1)%17))%17)*((10*((10*1*1)%17)*((10*1*1)%17))%17)%17`
3 | `(10*((10*1*1)%17)*((10*1*1)%17))%17`
1 | `(10*1*1)%17`
0 | `0`

```js
// 求模的指数运算（y>=1）
function modexp(x, y, N){
  if(0 == y){
    return 1;
  }
  var z = modexp(x, Math.floor(y/2), N);
  if (y%2 == 0) {
    return (z * z) % N;
  }else{
    return (x * z * z) % N;
  }
}
console.log(modexp(11, 11, 2));//1
console.log(modexp(10, 11, 2));//0
console.log(modexp(10, 6, 17));//9
```

### Euclid最大公因数（greatest common divisor）算法
- Euclid规则：如果x，y是正整数，且有X>=y，那么gcd(x, y) = gcd(x mod y, y)

```js
// Euclid求最大公约数方法（a>=b>=0）
function euclid(a, b){
    if(0 == b) return a;
    return euclid(b, a % b);
}
console.log(euclid(11, 11));//11
console.log(euclid(33, 22));//11
console.log(euclid(97, 79));//1
```

- Euclid拓展：用来求`gcd(a, b) = d = ax + by`的x和y

```js
// Euclid拓展（a>=b>=0）
function extend_euclid(a, b){
    if(0 == b) return [1, 0, a];
    var result = extend_euclid(b, a % b),
      x = result[0],
      y = result[1],
      d = result[2];
    return [y, x-Math.floor(a/b)*y, d];
}
console.log(extend_euclid(11, 11));//[ 0, 1, 11 ]
console.log(extend_euclid(33, 22));//[ 1, -1, 11 ]
console.log(extend_euclid(97, 79));//[ 22, -27, 1 ]
```

注：`a mod b = a - ⌊a/b⌋*b`


### 模的除法运算

不确定！！！

例，求100/27 mod 97
```
求乘法逆元：
97*22 + 79*-27 = 1
=> 79*-27 = 1 mod 97
=> -79 = 1/27 mod 97

乘法逆元带入：
100/27 mod 97
= 100 * 1/27 mod 97
= 100 * -79 mod 97
= 54
```

### 素性测试
- 费马小定理：p为素数，任意对于任意1<=a<p有`a^(p-1) = 1 mod p`

```js
// 素数测试算法（对于合数N，a的大多数无法通过测试）
function primality(N){
  var a = Math.floor(2 + Math.random() * (N-3));
  if (modexp(a, N - 1, N) == 1) {
    return true;
  }else{
    return false;
  }
}

// 求模的指数运算（y>=1），前面的算法
function modexp(x, y, N){
  if(0 == y){
    return 1;
  }
  var z = modexp(x, Math.floor(y/2), N);
  if (y%2 == 0) {
    return (z * z) % N;
  }else{
    return (x * z * z) % N;
  }
}
console.log(primality(11027));
console.log(primality(11026));
```
```js
// 素数测试算法（对于合数N，a的大多数无法通过测试）
function primality(N){
  // 降低出错概率到(2^-100)
  for (var i = 0; i < 100; i++) {
    var a = Math.floor(2 + Math.random() * (N-3));
    if (modexp(a, N - 1, N) != 1) {
      return false;
    }
  }
  return true;
}

// 求模的指数运算（y>=1），前面的算法
function modexp(x, y, N){
  if(0 == y){
    return 1;
  }
  var z = modexp(x, Math.floor(y/2), N);
  if (y%2 == 0) {
    return (z * z) % N;
  }else{
    return (x * z * z) % N;
  }
}
console.log(primality(11027));
console.log(primality(11026));
```

# 密码学
## 一次一密乱码本（one-time pad）和AES
使用密钥r进行异或加密解密

- 加密：er(x) = x ⊕ r
- 解密：er(er(x)) =(x ⊕ r) ⊕ r = x ⊕ (r ⊕ r) = x

### 一次一密乱码本
r与发送信息长度一样

```
const r = "101011100";

function encrypt(x){
  return (parseInt(x, 2) ^ parseInt(r, 2)).toString(2);
}

function unencrypt(x){
  return (parseInt(x, 2) ^ parseInt(r, 2)).toString(2);
}

// test
var msg = "111110000";
var encrypted = encrypt(msg);
console.log(`encrypted: ${encrypted}`);
var unencrypted = unencrypt(encrypted);
console.log(`unencrypted: ${unencrypted}`);
```
### AES
1. r通常定为128位（也有定为192位或256位的情况）
1. 定义一种双向映射机制er
1. 信息分成片段，每个片段用er加密

## RAS
### 生成密钥：
1. 找大整数p,q（素数测试算法）
2. 根据N=pq，求N（乘法）
2. 找任意与(p-1)(q-1)互素的数e（e通常取3或65537，但我测试了好几次取3都不是互素）
3. 根据ed≡(1 mod (p-1)(q-1))，求d（拓展Euclid算法）

此时公钥为(N,e)，私钥为(N,d)

```js
class ras {
    static genrsa() {
        let p, q, N, e, d;
        // 产生两个大素数
        p = this._genpri(4);
        q = this._genpri(4);
        // 求N
        N = p * q;
        // 求e和d
        [e, d] = this._get_eexp_and_inv((p - 1) * (q - 1));
        return {
            // 公钥
            pub_key: {
                N: N,
                e: e
            },
            // 私钥
            pri_key: {
                N: N,
                d: d
            }
        }
    }

    static encrypt(x, N, e) {
        return this._modexp(x, e, N);
    }

    static unencrypt(y, N, d) {
        return this._modexp(y, d, N);
    }

    // 生成素数
    static _genpri(size) {
        while (true) {
            let n = Math.floor((1 << size) - 1 + Math.random() * (1 << size));
            if (this._primality(n)) {
                return n;
            }
        }
    }

    // 获取加密指数和乘法余元（encryption exponent and multiplicative inverse）
    static _get_eexp_and_inv(N) {
        while (true) {
            let e = this._genpri(2);
            let d = this._extend_euclid(N, e)[1];
            // d > 1：乘法余元非负，且与N互素（模的指数运算无法使用负数）
            if (d > 1) {
                return [e, d];
            }
        }
    }

    // 模的指数运算
    static _modexp(x, y, N) {
        if (0 == y) {
            return 1;
        }
        // static模式下arguments.callee失效
        var z = this._modexp(x, Math.floor(y / 2), N);
        if (y % 2 == 0) {
            return (z * z) % N;
        } else {
            return (x * z * z) % N;
        }
    }

    // 素数测试算法（对于合数N，a的大多数无法通过测试）
    static _primality(N) {
        // 降低出错概率到(2^-100)
        for (var i = 0; i < 100; i++) {
            var a = Math.floor(2 + Math.random() * (N - 3));
            
            if (this._modexp(a, N - 1, N) != 1) {
                return false;
            }
        }
        return true;
    }

    // Euclid拓展（a>=b>=0）
    static _extend_euclid(a, b) {
        if (0 == b) return [1, 0, a];
        var result = this._extend_euclid(b, a % b),
            x = result[0],
            y = result[1],
            d = result[2];
        return [y, x - Math.floor(a / b) * y, d];
    }
}


// test
let msg = 123;
let test_res = ras.genrsa();
console.log(`test_res：`, test_res);
let encrypted = ras.encrypt(msg, test_res.pub_key.N, test_res.pub_key.e);
console.log(`encrypted: ${msg} -> ${encrypted}`);
let unencrypted = ras.unencrypt(encrypted, test_res.pri_key.N, test_res.pri_key.d);
console.log(`unencrypted: ${encrypted} -> ${unencrypted}`);
```

### 加密解密
1. 加密：y=x^e mod N
2. 解密：x=y^d mod N

### 破解？
方法1：尝试所有可能的x判断`x^e = y mod N`是否成立
方法2：对N因式分解，得到p和q，进而计算出d

### 散列表
散列表大小设为素数冲突概率小！

例：IP地址的散列
```js
// 未做解决冲突
function hash_IP(num) {
    var a = [],
        ip_table = new Array(num);
    for (let i = 0; i < 4; i++) {
        a[i] = Math.floor(Math.random() * num);
    }
    return function (IP) {
        let d, sum = 0;
        d = IP.split('.');
        for (let i = 0; i < 4; i++) {
            sum += +d[i] * a[i];
        }
        ip_table[Math.floor(sum % num)] = {
            ip: IP,
            data: IP
        }
        return ip_table;
    }
}
var hi = hash_IP(100)
console.log(hi('127.0.0.1'));
console.log(hi('60.59.44.33'));
console.log(hi('192.110.119.115'));
```


## 分治算法
### 乘法
递归将乘数分为两段，并将 T(n) = 4T(n/2) + O(n) 的方法优化为 
T(n) = 3T(n/2) + O(n) 的方法

效率：  
由普通的 O(n^2) 提高到 O(3^log2(n))（约为O(n^1.59)）  
PS: O(3^log2(n)) = O(n^log2(3)) 指数对数一顿推就出来了

算法：
```
令  
x = xl + xr  
y = yl + yr

得
xy = (xl + xr)(yl + yr) = xlyl + (xlyr + xryl) + xryr

其中
(xlyr + ylxr) = (xl + xr)(yl + yr) - xlyl - xryr

令  
P1 = xlyl  
P2 = xryr  
P3 = (xl + xr)(yl + yr)  

则
xy = P1 + (P3-P2-P1) + P2
```

### 主定理
T(n) = aT(n/b) + O(n^d)

- d > logb(a) : T(n) = O(n^d)
- d = logb(a) : T(n) = O((n^d)*log(n))
- d < logb(a) : T(n) = O(n^(logb(a)))

递归树宽a^logb(n)，高logb(n)

### 合并排序
T(n) = 2T(n/2) + O(n) = O(nlogn)

递归：
```
test_arr = [10, -1, 2, 3, 9, 10 ,9];
function mergesort(arr){
  if (arr.length > 1) {
    // 将两个排序好的数组进行连接
    return merge(mergesort(arr.slice(0, Math.floor(arr.length/2))), 
      mergesort(arr.slice(Math.floor(arr.length/2), arr.length)));
  }else{
    return arr;
  }
}
function merge(arr1, arr2){
  if(arr1.length == 0) return arr2;
  if(arr2.length == 0) return arr1;
  if (arr1[0] > arr2[0]) {
    return [arr1[0]].concat(merge(arr1.slice(1, arr1.length), arr2));
  }else{
    return [arr2[0]].concat(merge(arr2.slice(1, arr2.length), arr1));
  }
}
console.log(mergesort(test_arr));
```

迭代：
```
test_arr = [10, -1, 2, 3, 9, 10 ,9];
function interative_mergesort(arr){
  var temp_arr = test_arr.map((d)=>{
    return [d];
  });
  while(temp_arr.length > 1){
    temp_arr.push(merge(temp_arr.pop(), temp_arr.pop()))
  }
  return temp_arr[0];
}
function merge(arr1, arr2){
  if(arr1.length == 0) return arr2;
  if(arr2.length == 0) return arr1;
  if (arr1[0] > arr2[0]) {
    return [arr1[0]].concat(merge(arr1.slice(1, arr1.length), arr2));
  }else{
    return [arr2[0]].concat(merge(arr2.slice(1, arr1.length), arr1));
  }
}
console.log(interative_mergesort(test_arr));
```

### 寻找中项（选择有序数组的某项）
用快速排序的思想，递归找出SL SV SR缩小范围

效率：  
最好：T(n) = T(n/2) + O(n) = O(n)  
最坏：T(n) = T(n - 1) + O(n) = O(n^2)  

PS：快速排序是超大文件排序算法的基础

### 矩阵乘法
使用T(n) = 7T(n/2) + O(n^2)的分治算法可以从传统的 O(n^3) 优化到 O(n^log2(7))

## 快速傅里叶变换（FFT）

### 预备知识
- 性质
一个d次多项式被其在任意d+1个不同点出的取值所唯一确定（d+1个不同点处的取值可以列出d个方程，解出a0, a1, ..., ad）

- 多项式A(x)=a0*(x^0) + a1*(x^1) + ... + ad*(x^d)的表示
1. 系数：a0, a1, ..., ad
2. 值：A(x0), A(x1), ..., A(xd) 

- 系数与值的关系  
系数->计算->值  
值->插值->系数

### 问题转化
计算A(x)*B(x) = C(x)的问题转化成计算A(x)和B(x)在2d+1个不同点处的取值的乘积，然后对这些乘积插值获取C(x)的系数

留个坑。。

# 图的分解

# 图中的路径

# 贪心算法

## 最小生成树

## Huffman编码

## Hron公式

# 动态规划

## 最长递增子序列
